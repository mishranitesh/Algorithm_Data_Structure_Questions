There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

nums1 = [1, 3]      nums2 = [2]     --> The median is 2.0

nums1 = [1, 2]      nums2 = [3, 4]  --> The median is (2 + 3)/2 = 2.5

nums1 = []          nums2 = [1]     --> The median is 1.0

--------------------------------------------------------------------------------------------------------

// Macro to check for break condition
#define CHECK_CONDITION_TO_BREAK                                            \
            if (k == indx1 && indx2 == 0) {                                 \
                median_result = t_nums[indx1];                              \
                break;                                                      \
            } else if (k - 1 == indx1 && k == indx2) {                      \
                median_result = (t_nums[indx1] + t_nums[indx2]) / 2.0;      \
                break;                                                      \
            }                                                               \

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        
        // Logic to handle corner cases
        std::size_t n1_s = nums1.size(), n2_s = nums2.size();
        if (n1_s == 0 && n2_s == 0) {
            return 0.0;
        } else if (n1_s == 0 && n2_s != 0) {
            if (n2_s % 2 == 0) {
                int i1 = (n2_s / 2) - 1;
                return (nums2[i1] + nums2[i1 + 1]) / 2.0;
            } else {
                return (nums2[n2_s / 2]);
            }
        } else if (n1_s != 0 && n2_s == 0) {
            if (n1_s % 2 == 0) {
                int i1 = (n1_s / 2) - 1;
                return (nums1[i1] + nums1[i1 + 1]) / 2.0;
            } else {
                return (nums1[n1_s / 2]);
            }
        }
        
        // Logic to handle other cases
        std::size_t t_size = n1_s + n2_s, indx1 = 0, indx2 = 0;
        int i = 0, j = 0, k = -1;
        double median_result = 0.0;
        std::vector<int> t_nums(t_size);
        
        if (t_size % 2 == 0) {  // Even
            indx1 = (t_size / 2) - 1;
            indx2 = indx1 + 1;
        } else {                // Odd
            indx1 = t_size / 2;
        }
        
        // Logic to implement Merging of two vectors
        while (i < n1_s && j < n2_s) {
            if (nums1[i] <= nums2[j]) {
                t_nums[++k] = nums1[i];
                ++i;
            } else {
                t_nums[++k] = nums2[j];
                ++j;
            }
            
            CHECK_CONDITION_TO_BREAK
        }
        
        // Logic to implement merging of remaining elements
        if (median_result == 0.0) {
            if (i == n1_s) {
                while (j < n2_s) {
                    t_nums[++k] = nums2[j];
                    ++j;
                    
                    CHECK_CONDITION_TO_BREAK
                }
            } else if (j == n2_s) {
                while (i < n1_s) {
                    t_nums[++k] = nums1[i];
                    ++i;
                    
                    CHECK_CONDITION_TO_BREAK
                }
            }
        }
        
        return median_result;
    }
};

--------------------------------------------------------------------------------------------------------